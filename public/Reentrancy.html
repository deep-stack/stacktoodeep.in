<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Reentrancy</title>
  <link rel="stylesheet" href="reset.css" />
  <link rel="stylesheet" href="index.css" />
  <style>
    .title {
      text-align: left;
      font-size: 2em;
      margin-bottom: 0;
    }
    .subtitle {
      text-align: left;
      font-size: 1em;
      color: #555;
      margin-top: 0;
    }
  </style>
</head>
<body>
<table class="header">
  <tr>
    <td colspan="2" class="width-auto">
      <h1 class="title">Reentrancy</h1>
    </td>
  </tr>
  <tr>
    <th class="width-min">Organization</th>
    <td class="width-auto">DeepStack Software Pvt. Ltd.</td>
  </tr>
  <tr>
    <th class="width-min">Org URL</th>
    <td class="width-auto"><a href="https://www.deepstacksoft.com">https://www.deepstacksoft.com</a></td>
  </tr>
  </tr>
</table>
<nav id="TOC" role="doc-toc">
      <h2 id="toc-title">Contents</h2>
    <ul class="incremental">
    <li><a href="#introduction"
    id="toc-introduction">Introduction</a></li>
    <li><a href="#how-reentrancy-attacks-work"
    id="toc-how-reentrancy-attacks-work">How Reentrancy Attacks
    Work</a></li>
    <li><a href="#how-to-prevent-reentrancy-attacks"
    id="toc-how-to-prevent-reentrancy-attacks">How to Prevent Reentrancy
    Attacks</a>
    <ul class="incremental">
    <li><a href="#checks-effects-interactions-cei-pattern"
    id="toc-checks-effects-interactions-cei-pattern">Checks-Effects-Interactions
    (CEI) Pattern</a></li>
    <li><a href="#reentrancy-guard" id="toc-reentrancy-guard">Reentrancy
    Guard</a></li>
    </ul></li>
    <li><a href="#conclusion" id="toc-conclusion">Conclusion</a></li>
    </ul>
</nav>
<nav>
<a href="index.html"><button>Back</button></a>
</nav>
<p><strong>Posted on: 2024-09-18</strong></p>
<h2 id="introduction">Introduction</h2>
<p>In Solidity smart contracts, external calls to unknow or untrusted
contracts can expose your contract to a <strong>reentrancy
attack</strong>. A reentrancy attack occurs when an attacker repeatedly
calls the vulnerable contract’s function before the original function
completes, exploiting the contract’s logic to withdraw funds multiple
times before the state is updated.</p>
<p>This post will walk through the mechanics of a reentrancy attack, and
how to protect your contracts using two common techniques:
<strong>Checks-Effects-Interactions (CEI)</strong> and
<strong>Reentrancy Guard</strong>.</p>
<h2 id="how-reentrancy-attacks-work">How Reentrancy Attacks Work</h2>
<p>Let’s break down how the reentrancy attack works using two contracts:
<code>Victim</code> and <code>Attack</code></p>
<p><img src="codeblock-13.png" /></p>
<ul class="incremental">
<li><strong>Deposit Funds</strong>: The attacker calls the
<code>attack()</code> function in the <code>Attack</code> contract. This
calls <code>victim.deposit()</code> to deposit some <code>ETH</code>
into the <code>Victim</code> contract. The <code>Victim</code> contract
updates the attacker’s balance.<br></li>
<li><strong>Initial Withdrawal:</strong> Next, the <code>attack()</code>
function calls <code>victim.withdraw()</code> to withdraw the deposited
<code>ETH</code> from the <code>Victim</code> contract. Here, the
vulnerability is triggered because <code>withdraw()</code> sends the ETH
back to the attacker before updating the balance.</li>
<li><strong>Fallback Trigger:</strong> Since
<code>Victim.withdraw()</code> sends ETH to the attacker, the attacker’s
contract’s fallback function (<code>fallback()</code>) is called, which
once again calls <code>victim.withdraw()</code>. This happens before the
balance of the attacker is updated in <code>Victim</code>, allowing them
to withdraw more than they originally deposited.</li>
<li><strong>Repeat:</strong> This recursive call keeps draining funds
from the <code>Victim</code> contract until all ETH is withdrawn or the
transaction runs out of gas.</li>
</ul>
<h2 id="how-to-prevent-reentrancy-attacks">How to Prevent Reentrancy
Attacks</h2>
<p>Here are two methods you can use to protect your contract from
reentrancy attacks</p>
<h3
id="checks-effects-interactions-cei-pattern">Checks-Effects-Interactions
(CEI) Pattern</h3>
<p>Refactoring your contract code in way that updates the state
variables before handing over the execution control to some unknown
address</p>
<p><img src="codeblock-14.png" /></p>
<p>By shifting the (<code>balances[msg.sender] = 0;</code>) before the
external call, this way the attacker contract won’t be able to take
advantage of later state change since the balance will already be set to
0, preventing further withdrawals.</p>
<h3 id="reentrancy-guard">Reentrancy Guard</h3>
<p>Another method is to use a <strong>reentrancy guard</strong>, which
is a simple boolean flag that locks the contract during execution,
preventing any reentrant calls.</p>
<p>Here’s how you can implement it manually:</p>
<p><img src="codeblock-15.png" /></p>
<p>Alternatively, you can use <strong>OpenZeppelin’s
ReentrancyGuard</strong> to handle this for you. Simply inherit the
<code>ReentrancyGuard</code> contract and use the
<code>nonReentrant</code> modifier</p>
<p><img src="codeblock-16.png" /></p>
<p>The <code>nonReentrant</code> modifier ensures that the
<code>withdraw()</code> function cannot be called again until it
completes execution.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Reentrancy attacks can be devastating for smart contracts, allowing
attackers to drain funds by exploiting logic vulnerabilities. By using
the <strong>Checks-Effects-Interactions (CEI)</strong> pattern or
implementing <strong>Reentrancy Guard</strong>, you can safeguard your
contracts from this common attack vector.</p>
<p>Always ensure your contract’s state is updated before external calls
or use established libraries like <strong>OpenZeppelin</strong> to
simplify protection measures.</p>
  <script src="index.js"></script>
</body>
</html>
